# https://adventofcode.com/2017/day/21
struct Rule
    from::Array
    to::Array
    s::Int64

    Rule(data::String) = begin
        d = map(String, split(data, " => "))
        s = findfirst(d[1], '/') - 1
        from = flipdim(reshape(map(String, split(split(d[1], '/') |> join, "")), s, :) |> rotl90, 1)
        to = flipdim(reshape(map(String, split(split(d[2], '/') |> join, "")), s+1, :) |> rotl90, 1)
        new(from, to, s)
    end

    Rule(r::Rule, f) = begin
        from = r.from |> f
        new(from, r.to, r.s)
    end
end

variations(r::Rule) = Channel() do c
    push!(c, r)
    push!(c, Rule(r, rotl90))
    push!(c, Rule(r, rotr90))
    push!(c, Rule(r, rot180))

    push!(c, Rule(r, x -> flipdim(x, 1)))
    push!(c, Rule(r, x -> flipdim(x, 1) |> rotl90))
    push!(c, Rule(r, x -> flipdim(x, 1) |> rotr90))
    push!(c, Rule(r, x -> flipdim(x, 1) |> rot180))

    push!(c, Rule(r, x -> flipdim(x, 2)))
    push!(c, Rule(r, x -> flipdim(x, 2) |> rotl90))
    push!(c, Rule(r, x -> flipdim(x, 2) |> rotr90))
    push!(c, Rule(r, x -> flipdim(x, 2) |> rot180))
end

# TODO
# match(g::Array, r::Rule) = Iterators.filter(rv -> g == rv.from, variations(r))
function match(g::Array, r::Rule)
    for rv in variations(r)
        if rv.from == g
            return rv
        end
    end
end
match(g::Array, rs::Array) = [x for x in map(r -> match(g, r), filter(r -> r.s * r.s == length(g), rs)) if x != nothing] |> first

function split_matrix(g::Array, n::Int64)
    Channel() do c
        for i in 1:n:convert(Int, sqrt(length(g)))
            for j in 1:n:convert(Int, sqrt(length(g)))
                push!(c, g[i:i+n-1,j:j+n-1])
            end
        end
    end
end

function apply(g::Array, rs::Array)
    l = length(g)
    if l == 4 || l == 9
        return match(g, rs).to
    end

    splitter = l % 2 == 0 ? split_matrix(g, 2) : split_matrix(g, 3)
    matrices = map(x -> match(x, rules).to, splitter)
    step_size = convert(Int, matrices |> length |> sqrt)
    vcat([hcat(matrices[i:i+step_size-1]...) for i in 1:step_size:length(matrices)]...)
end

iterate(g::Array, rs::Array; iterations::Int64 = 1) = foldl((x, y) -> apply(x, rs), g, 1:iterations)

# https://adventofcode.com/2017/day/21/input
const data = [
    "../.. => .##/.##/###",
    "#./.. => .../#.#/###",
    "##/.. => .##/.../.#.",
    ".#/#. => ###/.#./##.",
    "##/#. => .#./#../#.#",
    "##/## => .##/#.#/###",
    ".../.../... => ####/.##./####/.#..",
    "#../.../... => ..../..##/#.../.##.",
    ".#./.../... => #.#./##.#/#.../#.#.",
    "##./.../... => .#../.##./#.../....",
    "#.#/.../... => ###./..##/..##/##.#",
    "###/.../... => .###/#.##/..../....",
    ".#./#../... => ##.#/#..#/.##./...#",
    "##./#../... => ..../#..#/#.#./...#",
    "..#/#../... => #.##/.#../.#.#/###.",
    "#.#/#../... => ##../.#.#/...#/...#",
    ".##/#../... => ##.#/.##./..#./##.#",
    "###/#../... => ...#/####/..#./#...",
    ".../.#./... => ##.#/#.#./..##/.##.",
    "#../.#./... => .#.#/#.##/.##./....",
    ".#./.#./... => #..#/#.../.##./....",
    "##./.#./... => ###./###./..##/#..#",
    "#.#/.#./... => .###/...#/###./###.",
    "###/.#./... => ...#/..##/..#./#.##",
    ".#./##./... => .##./.#../...#/..#.",
    "##./##./... => .###/..#./.###/###.",
    "..#/##./... => .#.#/..#./..#./...#",
    "#.#/##./... => .#.#/##../#.../.##.",
    ".##/##./... => .##./...#/#.##/###.",
    "###/##./... => ...#/###./####/#.##",
    ".../#.#/... => #.#./#.../#.#./..#.",
    "#../#.#/... => ###./##../..#./.#..",
    ".#./#.#/... => #.../..##/#..#/#.#.",
    "##./#.#/... => #.#./.##./#..#/##.#",
    "#.#/#.#/... => #.##/.#.#/#..#/.#.#",
    "###/#.#/... => #.../##.#/###./....",
    ".../###/... => ..##/...#/##.#/###.",
    "#../###/... => .#.#/...#/#.##/.#..",
    ".#./###/... => ####/#.../..#./.#.#",
    "##./###/... => ..../####/#.##/#..#",
    "#.#/###/... => ####/..#./####/.#.#",
    "###/###/... => ..##/..../...#/.#..",
    "..#/.../#.. => .###/..##/.#.#/.##.",
    "#.#/.../#.. => #.##/#..#/.#.#/##.#",
    ".##/.../#.. => #.##/####/.#.#/..#.",
    "###/.../#.. => ##../##.#/..../##..",
    ".##/#../#.. => ...#/####/..##/.##.",
    "###/#../#.. => ..#./...#/#.../##.#",
    "..#/.#./#.. => #..#/##.#/..##/#..#",
    "#.#/.#./#.. => ..../.###/#..#/..##",
    ".##/.#./#.. => ..#./...#/..##/...#",
    "###/.#./#.. => ...#/..../##.#/....",
    ".##/##./#.. => .#../..##/...#/.#.#",
    "###/##./#.. => .###/#.#./####/#.#.",
    "#../..#/#.. => .###/##.#/##../##..",
    ".#./..#/#.. => ##../.#../###./##.#",
    "##./..#/#.. => #..#/####/####/..##",
    "#.#/..#/#.. => ..##/..../###./..##",
    ".##/..#/#.. => ..##/.#.#/.#../.#..",
    "###/..#/#.. => ...#/.###/.###/.#.#",
    "#../#.#/#.. => ##../##../##.#/.##.",
    ".#./#.#/#.. => ...#/.##./.#.#/#...",
    "##./#.#/#.. => .##./.#../.#../#...",
    "..#/#.#/#.. => ..##/##.#/####/###.",
    "#.#/#.#/#.. => ..../.###/#.../#..#",
    ".##/#.#/#.. => ..#./#.#./.#../...#",
    "###/#.#/#.. => ##.#/#.../##.#/.##.",
    "#../.##/#.. => ..../#.../..#./####",
    ".#./.##/#.. => #..#/.#../#.#./..##",
    "##./.##/#.. => .###/..##/###./....",
    "#.#/.##/#.. => .###/.##./.###/#.##",
    ".##/.##/#.. => #.##/###./.##./...#",
    "###/.##/#.. => ...#/#.##/.##./#.#.",
    "#../###/#.. => #..#/.###/.###/#.#.",
    ".#./###/#.. => ..#./#.#./..../...#",
    "##./###/#.. => ..##/##../#..#/....",
    "..#/###/#.. => ..##/.#../.#../###.",
    "#.#/###/#.. => ..#./.###/..../...#",
    ".##/###/#.. => .##./###./#.../#.##",
    "###/###/#.. => ##.#/..../.##./##.#",
    ".#./#.#/.#. => .##./.#.#/####/....",
    "##./#.#/.#. => ##.#/#.##/####/.#..",
    "#.#/#.#/.#. => ####/.##./##.#/...#",
    "###/#.#/.#. => #..#/#.##/.##./###.",
    ".#./###/.#. => .#../..../.##./##.#",
    "##./###/.#. => ##.#/.#../#.../.###",
    "#.#/###/.#. => ###./###./.#../###.",
    "###/###/.#. => #..#/#.../#..#/.#.#",
    "#.#/..#/##. => #..#/#.../##../###.",
    "###/..#/##. => #.../.#../.###/#...",
    ".##/#.#/##. => .#.#/.##./.#../##.#",
    "###/#.#/##. => #.../..../##../.###",
    "#.#/.##/##. => .#.#/##../.###/#.#.",
    "###/.##/##. => ###./..#./##.#/.###",
    ".##/###/##. => ..#./.#.#/##.#/#.#.",
    "###/###/##. => ##../.#.#/#..#/.#.#",
    "#.#/.../#.# => ##../###./..#./##.#",
    "###/.../#.# => .#../##../..#./##.#",
    "###/#../#.# => ###./#..#/####/....",
    "#.#/.#./#.# => .###/..../.###/##.#",
    "###/.#./#.# => ###./.###/..##/.#.#",
    "###/##./#.# => ..#./..##/#..#/#.##",
    "#.#/#.#/#.# => .#.#/.#../.#.#/#.##",
    "###/#.#/#.# => .###/#.../##../.###",
    "#.#/###/#.# => .#../...#/..../...#",
    "###/###/#.# => #..#/##.#/..#./#...",
    "###/#.#/### => .###/.#.#/..#./####",
    "###/###/### => ##.#/..##/.#../..##",
]
const grid = [
    "." "#" ".";
    "." "." "#";
    "#" "#" "#";
]

const rules = [rv for r in Rule.(data) for rv in variations(r)]

g = iterate(grid, rules, iterations=5)
count(x -> x == "#", g) |> println

g = iterate(g, rules, iterations=18-5)
count(x -> x == "#", g) |> println
